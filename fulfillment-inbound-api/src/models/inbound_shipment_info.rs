/* 
 * Selling Partner API for Fulfillment Inbound
 *
 * The Selling Partner API for Fulfillment Inbound lets you create applications that create and update inbound shipments of inventory to Amazon's fulfillment network.
 *
 * OpenAPI spec version: v0
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */

/// InboundShipmentInfo : Information about the seller's inbound shipments. Returned by the listInboundShipments operation.

#[allow(unused_imports)]
use serde_json::Value;

#[derive(Debug, Serialize, Deserialize)]
pub struct InboundShipmentInfo {
  /// The shipment identifier submitted in the request.
  #[serde(rename = "ShipmentId")]
  shipment_id: Option<String>,
  /// The name for the inbound shipment.
  #[serde(rename = "ShipmentName")]
  shipment_name: Option<String>,
  /// The return address.
  #[serde(rename = "ShipFromAddress")]
  ship_from_address: ::models::Address,
  /// An Amazon fulfillment center identifier created by Amazon.
  #[serde(rename = "DestinationFulfillmentCenterId")]
  destination_fulfillment_center_id: Option<String>,
  #[serde(rename = "ShipmentStatus")]
  shipment_status: Option<::models::ShipmentStatus>,
  #[serde(rename = "LabelPrepType")]
  label_prep_type: Option<::models::LabelPrepType>,
  /// Indicates whether or not an inbound shipment contains case-packed boxes. When AreCasesRequired = true for an inbound shipment, all items in the inbound shipment must be case packed.
  #[serde(rename = "AreCasesRequired")]
  are_cases_required: bool,
  /// Date by which the shipment must arrive at the Amazon fulfillment center to avoid delivery promise breaks for pre-ordered items.
  #[serde(rename = "ConfirmedNeedByDate")]
  confirmed_need_by_date: Option<::models::DateStringType>,
  #[serde(rename = "BoxContentsSource")]
  box_contents_source: Option<::models::BoxContentsSource>,
  /// An estimate of the manual processing fee charged by Amazon for boxes without box content information. This is only returned when BoxContentsSource is NONE.
  #[serde(rename = "EstimatedBoxContentsFee")]
  estimated_box_contents_fee: Option<::models::BoxContentsFeeDetails>
}

impl InboundShipmentInfo {
  /// Information about the seller's inbound shipments. Returned by the listInboundShipments operation.
  pub fn new(ship_from_address: ::models::Address, are_cases_required: bool) -> InboundShipmentInfo {
    InboundShipmentInfo {
      shipment_id: None,
      shipment_name: None,
      ship_from_address: ship_from_address,
      destination_fulfillment_center_id: None,
      shipment_status: None,
      label_prep_type: None,
      are_cases_required: are_cases_required,
      confirmed_need_by_date: None,
      box_contents_source: None,
      estimated_box_contents_fee: None
    }
  }

  pub fn set_shipment_id(&mut self, shipment_id: String) {
    self.shipment_id = Some(shipment_id);
  }

  pub fn with_shipment_id(mut self, shipment_id: String) -> InboundShipmentInfo {
    self.shipment_id = Some(shipment_id);
    self
  }

  pub fn shipment_id(&self) -> Option<&String> {
    self.shipment_id.as_ref()
  }

  pub fn reset_shipment_id(&mut self) {
    self.shipment_id = None;
  }

  pub fn set_shipment_name(&mut self, shipment_name: String) {
    self.shipment_name = Some(shipment_name);
  }

  pub fn with_shipment_name(mut self, shipment_name: String) -> InboundShipmentInfo {
    self.shipment_name = Some(shipment_name);
    self
  }

  pub fn shipment_name(&self) -> Option<&String> {
    self.shipment_name.as_ref()
  }

  pub fn reset_shipment_name(&mut self) {
    self.shipment_name = None;
  }

  pub fn set_ship_from_address(&mut self, ship_from_address: ::models::Address) {
    self.ship_from_address = ship_from_address;
  }

  pub fn with_ship_from_address(mut self, ship_from_address: ::models::Address) -> InboundShipmentInfo {
    self.ship_from_address = ship_from_address;
    self
  }

  pub fn ship_from_address(&self) -> &::models::Address {
    &self.ship_from_address
  }


  pub fn set_destination_fulfillment_center_id(&mut self, destination_fulfillment_center_id: String) {
    self.destination_fulfillment_center_id = Some(destination_fulfillment_center_id);
  }

  pub fn with_destination_fulfillment_center_id(mut self, destination_fulfillment_center_id: String) -> InboundShipmentInfo {
    self.destination_fulfillment_center_id = Some(destination_fulfillment_center_id);
    self
  }

  pub fn destination_fulfillment_center_id(&self) -> Option<&String> {
    self.destination_fulfillment_center_id.as_ref()
  }

  pub fn reset_destination_fulfillment_center_id(&mut self) {
    self.destination_fulfillment_center_id = None;
  }

  pub fn set_shipment_status(&mut self, shipment_status: ::models::ShipmentStatus) {
    self.shipment_status = Some(shipment_status);
  }

  pub fn with_shipment_status(mut self, shipment_status: ::models::ShipmentStatus) -> InboundShipmentInfo {
    self.shipment_status = Some(shipment_status);
    self
  }

  pub fn shipment_status(&self) -> Option<&::models::ShipmentStatus> {
    self.shipment_status.as_ref()
  }

  pub fn reset_shipment_status(&mut self) {
    self.shipment_status = None;
  }

  pub fn set_label_prep_type(&mut self, label_prep_type: ::models::LabelPrepType) {
    self.label_prep_type = Some(label_prep_type);
  }

  pub fn with_label_prep_type(mut self, label_prep_type: ::models::LabelPrepType) -> InboundShipmentInfo {
    self.label_prep_type = Some(label_prep_type);
    self
  }

  pub fn label_prep_type(&self) -> Option<&::models::LabelPrepType> {
    self.label_prep_type.as_ref()
  }

  pub fn reset_label_prep_type(&mut self) {
    self.label_prep_type = None;
  }

  pub fn set_are_cases_required(&mut self, are_cases_required: bool) {
    self.are_cases_required = are_cases_required;
  }

  pub fn with_are_cases_required(mut self, are_cases_required: bool) -> InboundShipmentInfo {
    self.are_cases_required = are_cases_required;
    self
  }

  pub fn are_cases_required(&self) -> &bool {
    &self.are_cases_required
  }


  pub fn set_confirmed_need_by_date(&mut self, confirmed_need_by_date: ::models::DateStringType) {
    self.confirmed_need_by_date = Some(confirmed_need_by_date);
  }

  pub fn with_confirmed_need_by_date(mut self, confirmed_need_by_date: ::models::DateStringType) -> InboundShipmentInfo {
    self.confirmed_need_by_date = Some(confirmed_need_by_date);
    self
  }

  pub fn confirmed_need_by_date(&self) -> Option<&::models::DateStringType> {
    self.confirmed_need_by_date.as_ref()
  }

  pub fn reset_confirmed_need_by_date(&mut self) {
    self.confirmed_need_by_date = None;
  }

  pub fn set_box_contents_source(&mut self, box_contents_source: ::models::BoxContentsSource) {
    self.box_contents_source = Some(box_contents_source);
  }

  pub fn with_box_contents_source(mut self, box_contents_source: ::models::BoxContentsSource) -> InboundShipmentInfo {
    self.box_contents_source = Some(box_contents_source);
    self
  }

  pub fn box_contents_source(&self) -> Option<&::models::BoxContentsSource> {
    self.box_contents_source.as_ref()
  }

  pub fn reset_box_contents_source(&mut self) {
    self.box_contents_source = None;
  }

  pub fn set_estimated_box_contents_fee(&mut self, estimated_box_contents_fee: ::models::BoxContentsFeeDetails) {
    self.estimated_box_contents_fee = Some(estimated_box_contents_fee);
  }

  pub fn with_estimated_box_contents_fee(mut self, estimated_box_contents_fee: ::models::BoxContentsFeeDetails) -> InboundShipmentInfo {
    self.estimated_box_contents_fee = Some(estimated_box_contents_fee);
    self
  }

  pub fn estimated_box_contents_fee(&self) -> Option<&::models::BoxContentsFeeDetails> {
    self.estimated_box_contents_fee.as_ref()
  }

  pub fn reset_estimated_box_contents_fee(&mut self) {
    self.estimated_box_contents_fee = None;
  }

}



