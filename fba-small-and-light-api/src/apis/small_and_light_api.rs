/* 
 * Selling Partner API for FBA Small And Light
 *
 * The Selling Partner API for FBA Small and Light lets you help sellers manage their listings in the Small and Light program. The program reduces the cost of fulfilling orders for small and lightweight FBA inventory. You can enroll or remove items from the program and check item eligibility and enrollment status. You can also preview the estimated program fees charged to a seller for items sold while enrolled in the program.
 *
 * OpenAPI spec version: v1
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */

use std::rc::Rc;
use std::borrow::Borrow;
use std::borrow::Cow;
use std::collections::HashMap;

use hyper;
use serde_json;
use futures;
use futures::{Future, Stream};

use hyper::header::UserAgent;

use super::{Error, configuration};

pub struct SmallAndLightApiClient<C: hyper::client::Connect> {
    configuration: Rc<configuration::Configuration<C>>,
}

impl<C: hyper::client::Connect> SmallAndLightApiClient<C> {
    pub fn new(configuration: Rc<configuration::Configuration<C>>) -> SmallAndLightApiClient<C> {
        SmallAndLightApiClient {
            configuration: configuration,
        }
    }
}

pub trait SmallAndLightApi {
    fn delete_small_and_light_enrollment_by_seller_sku(&self, seller_sku: &str, marketplace_ids: Vec<String>) -> Box<Future<Item = (), Error = Error<serde_json::Value>>>;
    fn get_small_and_light_eligibility_by_seller_sku(&self, seller_sku: &str, marketplace_ids: Vec<String>) -> Box<Future<Item = ::models::SmallAndLightEligibility, Error = Error<serde_json::Value>>>;
    fn get_small_and_light_enrollment_by_seller_sku(&self, seller_sku: &str, marketplace_ids: Vec<String>) -> Box<Future<Item = ::models::SmallAndLightEnrollment, Error = Error<serde_json::Value>>>;
    fn get_small_and_light_fee_preview(&self, body: ::models::SmallAndLightFeePreviewRequest) -> Box<Future<Item = ::models::SmallAndLightFeePreviews, Error = Error<serde_json::Value>>>;
    fn put_small_and_light_enrollment_by_seller_sku(&self, seller_sku: &str, marketplace_ids: Vec<String>) -> Box<Future<Item = ::models::SmallAndLightEnrollment, Error = Error<serde_json::Value>>>;
}


impl<C: hyper::client::Connect>SmallAndLightApi for SmallAndLightApiClient<C> {
    fn delete_small_and_light_enrollment_by_seller_sku(&self, seller_sku: &str, marketplace_ids: Vec<String>) -> Box<Future<Item = (), Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Delete;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("marketplaceIds", &marketplace_ids.join(",").to_string());
            query.finish()
        };
        let uri_str = format!("{}/fba/smallAndLight/v1/enrollments/{sellerSKU}?{}", configuration.base_path, query_string, sellerSKU=seller_sku);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }




        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|_| futures::future::ok(()))
        )
    }

    fn get_small_and_light_eligibility_by_seller_sku(&self, seller_sku: &str, marketplace_ids: Vec<String>) -> Box<Future<Item = ::models::SmallAndLightEligibility, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("marketplaceIds", &marketplace_ids.join(",").to_string());
            query.finish()
        };
        let uri_str = format!("{}/fba/smallAndLight/v1/eligibilities/{sellerSKU}?{}", configuration.base_path, query_string, sellerSKU=seller_sku);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }




        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::SmallAndLightEligibility, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn get_small_and_light_enrollment_by_seller_sku(&self, seller_sku: &str, marketplace_ids: Vec<String>) -> Box<Future<Item = ::models::SmallAndLightEnrollment, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("marketplaceIds", &marketplace_ids.join(",").to_string());
            query.finish()
        };
        let uri_str = format!("{}/fba/smallAndLight/v1/enrollments/{sellerSKU}?{}", configuration.base_path, query_string, sellerSKU=seller_sku);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }




        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::SmallAndLightEnrollment, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn get_small_and_light_fee_preview(&self, body: ::models::SmallAndLightFeePreviewRequest) -> Box<Future<Item = ::models::SmallAndLightFeePreviews, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Post;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.finish()
        };
        let uri_str = format!("{}/fba/smallAndLight/v1/feePreviews?{}", configuration.base_path, query_string);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }



        let serialized = serde_json::to_string(&body).unwrap();
        req.headers_mut().set(hyper::header::ContentType::json());
        req.headers_mut().set(hyper::header::ContentLength(serialized.len() as u64));
        req.set_body(serialized);

        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::SmallAndLightFeePreviews, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn put_small_and_light_enrollment_by_seller_sku(&self, seller_sku: &str, marketplace_ids: Vec<String>) -> Box<Future<Item = ::models::SmallAndLightEnrollment, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Put;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("marketplaceIds", &marketplace_ids.join(",").to_string());
            query.finish()
        };
        let uri_str = format!("{}/fba/smallAndLight/v1/enrollments/{sellerSKU}?{}", configuration.base_path, query_string, sellerSKU=seller_sku);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }




        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::SmallAndLightEnrollment, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

}
