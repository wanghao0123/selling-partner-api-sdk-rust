/* 
 * Selling Partner API for Services
 *
 * With the Services API, you can build applications that help service providers get and modify their service orders.
 *
 * OpenAPI spec version: v1
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */

/// JobListing : The payload for the GetJobs operation.

#[allow(unused_imports)]
use serde_json::Value;

#[derive(Debug, Serialize, Deserialize)]
pub struct JobListing {
  /// Total result size of the query result.
  #[serde(rename = "totalResultSize")]
  total_result_size: Option<i32>,
  /// A generated string used to pass information to your next request.If nextPageToken is returned, pass the value of nextPageToken to the pageToken to get next results.
  #[serde(rename = "nextPageToken")]
  next_page_token: Option<String>,
  /// A generated string used to pass information to your next request.If previousPageToken is returned, pass the value of previousPageToken to the pageToken to get previous page results.
  #[serde(rename = "previousPageToken")]
  previous_page_token: Option<String>,
  /// List of job details for the given input.
  #[serde(rename = "jobs")]
  jobs: Option<Vec<::models::ServiceJob>>
}

impl JobListing {
  /// The payload for the GetJobs operation.
  pub fn new() -> JobListing {
    JobListing {
      total_result_size: None,
      next_page_token: None,
      previous_page_token: None,
      jobs: None
    }
  }

  pub fn set_total_result_size(&mut self, total_result_size: i32) {
    self.total_result_size = Some(total_result_size);
  }

  pub fn with_total_result_size(mut self, total_result_size: i32) -> JobListing {
    self.total_result_size = Some(total_result_size);
    self
  }

  pub fn total_result_size(&self) -> Option<&i32> {
    self.total_result_size.as_ref()
  }

  pub fn reset_total_result_size(&mut self) {
    self.total_result_size = None;
  }

  pub fn set_next_page_token(&mut self, next_page_token: String) {
    self.next_page_token = Some(next_page_token);
  }

  pub fn with_next_page_token(mut self, next_page_token: String) -> JobListing {
    self.next_page_token = Some(next_page_token);
    self
  }

  pub fn next_page_token(&self) -> Option<&String> {
    self.next_page_token.as_ref()
  }

  pub fn reset_next_page_token(&mut self) {
    self.next_page_token = None;
  }

  pub fn set_previous_page_token(&mut self, previous_page_token: String) {
    self.previous_page_token = Some(previous_page_token);
  }

  pub fn with_previous_page_token(mut self, previous_page_token: String) -> JobListing {
    self.previous_page_token = Some(previous_page_token);
    self
  }

  pub fn previous_page_token(&self) -> Option<&String> {
    self.previous_page_token.as_ref()
  }

  pub fn reset_previous_page_token(&mut self) {
    self.previous_page_token = None;
  }

  pub fn set_jobs(&mut self, jobs: Vec<::models::ServiceJob>) {
    self.jobs = Some(jobs);
  }

  pub fn with_jobs(mut self, jobs: Vec<::models::ServiceJob>) -> JobListing {
    self.jobs = Some(jobs);
    self
  }

  pub fn jobs(&self) -> Option<&Vec<::models::ServiceJob>> {
    self.jobs.as_ref()
  }

  pub fn reset_jobs(&mut self) {
    self.jobs = None;
  }

}



