/* 
 * Selling Partner APIs for Fulfillment Outbound
 *
 * The Selling Partner API for Fulfillment Outbound lets you create applications that help a seller fulfill Multi-Channel Fulfillment orders using their inventory in Amazon's fulfillment network. You can get information on both potential and existing fulfillment orders.
 *
 * OpenAPI spec version: 2020-07-01
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */

/// FeatureSku : Information about an SKU, including the count available, identifiers, and a list of overlapping SKUs that share the same inventory pool.

#[allow(unused_imports)]
use serde_json::Value;

#[derive(Debug, Serialize, Deserialize)]
pub struct FeatureSku {
  /// Used to identify an item in the given marketplace. SellerSKU is qualified by the seller's SellerId, which is included with every operation that you submit.
  #[serde(rename = "sellerSku")]
  seller_sku: Option<String>,
  /// The unique SKU used by Amazon's fulfillment network.
  #[serde(rename = "fnSku")]
  fn_sku: Option<String>,
  /// The Amazon Standard Identification Number (ASIN) of the item.
  #[serde(rename = "asin")]
  asin: Option<String>,
  /// The number of SKUs available for this service.
  #[serde(rename = "skuCount")]
  sku_count: Option<f32>,
  /// Other seller SKUs that are shared across the same inventory.
  #[serde(rename = "overlappingSkus")]
  overlapping_skus: Option<Vec<String>>
}

impl FeatureSku {
  /// Information about an SKU, including the count available, identifiers, and a list of overlapping SKUs that share the same inventory pool.
  pub fn new() -> FeatureSku {
    FeatureSku {
      seller_sku: None,
      fn_sku: None,
      asin: None,
      sku_count: None,
      overlapping_skus: None
    }
  }

  pub fn set_seller_sku(&mut self, seller_sku: String) {
    self.seller_sku = Some(seller_sku);
  }

  pub fn with_seller_sku(mut self, seller_sku: String) -> FeatureSku {
    self.seller_sku = Some(seller_sku);
    self
  }

  pub fn seller_sku(&self) -> Option<&String> {
    self.seller_sku.as_ref()
  }

  pub fn reset_seller_sku(&mut self) {
    self.seller_sku = None;
  }

  pub fn set_fn_sku(&mut self, fn_sku: String) {
    self.fn_sku = Some(fn_sku);
  }

  pub fn with_fn_sku(mut self, fn_sku: String) -> FeatureSku {
    self.fn_sku = Some(fn_sku);
    self
  }

  pub fn fn_sku(&self) -> Option<&String> {
    self.fn_sku.as_ref()
  }

  pub fn reset_fn_sku(&mut self) {
    self.fn_sku = None;
  }

  pub fn set_asin(&mut self, asin: String) {
    self.asin = Some(asin);
  }

  pub fn with_asin(mut self, asin: String) -> FeatureSku {
    self.asin = Some(asin);
    self
  }

  pub fn asin(&self) -> Option<&String> {
    self.asin.as_ref()
  }

  pub fn reset_asin(&mut self) {
    self.asin = None;
  }

  pub fn set_sku_count(&mut self, sku_count: f32) {
    self.sku_count = Some(sku_count);
  }

  pub fn with_sku_count(mut self, sku_count: f32) -> FeatureSku {
    self.sku_count = Some(sku_count);
    self
  }

  pub fn sku_count(&self) -> Option<&f32> {
    self.sku_count.as_ref()
  }

  pub fn reset_sku_count(&mut self) {
    self.sku_count = None;
  }

  pub fn set_overlapping_skus(&mut self, overlapping_skus: Vec<String>) {
    self.overlapping_skus = Some(overlapping_skus);
  }

  pub fn with_overlapping_skus(mut self, overlapping_skus: Vec<String>) -> FeatureSku {
    self.overlapping_skus = Some(overlapping_skus);
    self
  }

  pub fn overlapping_skus(&self) -> Option<&Vec<String>> {
    self.overlapping_skus.as_ref()
  }

  pub fn reset_overlapping_skus(&mut self) {
    self.overlapping_skus = None;
  }

}



