/* 
 * Selling Partner API for FBA Inventory
 *
 * The Selling Partner API for FBA Inventory lets you programmatically retrieve information about inventory in Amazon's fulfillment network. Today this API is available only in the North America region. In 2021 we plan to release this API in the Europe and Far East regions.
 *
 * OpenAPI spec version: v1
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */

/// ReservedQuantity : The quantity of reserved inventory.

#[allow(unused_imports)]
use serde_json::Value;

#[derive(Debug, Serialize, Deserialize)]
pub struct ReservedQuantity {
  /// The total number of units in Amazon's fulfillment network that are currently being picked, packed, and shipped; or are sidelined for measurement, sampling, or other internal processes.
  #[serde(rename = "totalReservedQuantity")]
  total_reserved_quantity: Option<i32>,
  /// The number of units reserved for customer orders.
  #[serde(rename = "pendingCustomerOrderQuantity")]
  pending_customer_order_quantity: Option<i32>,
  /// The number of units being transferred from one fulfillment center to another.
  #[serde(rename = "pendingTransshipmentQuantity")]
  pending_transshipment_quantity: Option<i32>,
  /// The number of units that have been sidelined at the fulfillment center for additional processing.
  #[serde(rename = "fcProcessingQuantity")]
  fc_processing_quantity: Option<i32>
}

impl ReservedQuantity {
  /// The quantity of reserved inventory.
  pub fn new() -> ReservedQuantity {
    ReservedQuantity {
      total_reserved_quantity: None,
      pending_customer_order_quantity: None,
      pending_transshipment_quantity: None,
      fc_processing_quantity: None
    }
  }

  pub fn set_total_reserved_quantity(&mut self, total_reserved_quantity: i32) {
    self.total_reserved_quantity = Some(total_reserved_quantity);
  }

  pub fn with_total_reserved_quantity(mut self, total_reserved_quantity: i32) -> ReservedQuantity {
    self.total_reserved_quantity = Some(total_reserved_quantity);
    self
  }

  pub fn total_reserved_quantity(&self) -> Option<&i32> {
    self.total_reserved_quantity.as_ref()
  }

  pub fn reset_total_reserved_quantity(&mut self) {
    self.total_reserved_quantity = None;
  }

  pub fn set_pending_customer_order_quantity(&mut self, pending_customer_order_quantity: i32) {
    self.pending_customer_order_quantity = Some(pending_customer_order_quantity);
  }

  pub fn with_pending_customer_order_quantity(mut self, pending_customer_order_quantity: i32) -> ReservedQuantity {
    self.pending_customer_order_quantity = Some(pending_customer_order_quantity);
    self
  }

  pub fn pending_customer_order_quantity(&self) -> Option<&i32> {
    self.pending_customer_order_quantity.as_ref()
  }

  pub fn reset_pending_customer_order_quantity(&mut self) {
    self.pending_customer_order_quantity = None;
  }

  pub fn set_pending_transshipment_quantity(&mut self, pending_transshipment_quantity: i32) {
    self.pending_transshipment_quantity = Some(pending_transshipment_quantity);
  }

  pub fn with_pending_transshipment_quantity(mut self, pending_transshipment_quantity: i32) -> ReservedQuantity {
    self.pending_transshipment_quantity = Some(pending_transshipment_quantity);
    self
  }

  pub fn pending_transshipment_quantity(&self) -> Option<&i32> {
    self.pending_transshipment_quantity.as_ref()
  }

  pub fn reset_pending_transshipment_quantity(&mut self) {
    self.pending_transshipment_quantity = None;
  }

  pub fn set_fc_processing_quantity(&mut self, fc_processing_quantity: i32) {
    self.fc_processing_quantity = Some(fc_processing_quantity);
  }

  pub fn with_fc_processing_quantity(mut self, fc_processing_quantity: i32) -> ReservedQuantity {
    self.fc_processing_quantity = Some(fc_processing_quantity);
    self
  }

  pub fn fc_processing_quantity(&self) -> Option<&i32> {
    self.fc_processing_quantity.as_ref()
  }

  pub fn reset_fc_processing_quantity(&mut self) {
    self.fc_processing_quantity = None;
  }

}



