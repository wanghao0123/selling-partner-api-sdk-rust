/* 
 * Selling Partner API for A+ Content Management
 *
 * With the A+ Content API, you can build applications that help selling partners add rich marketing content to their Amazon product detail pages. A+ content helps selling partners share their brand and product story, which helps buyers make informed purchasing decisions. Selling partners assemble content by choosing from content modules and adding images and text.
 *
 * OpenAPI spec version: 2020-11-01
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */

use std::rc::Rc;
use std::borrow::Borrow;
use std::borrow::Cow;
use std::collections::HashMap;

use hyper;
use serde_json;
use futures;
use futures::{Future, Stream};

use hyper::header::UserAgent;

use super::{Error, configuration};

pub struct AplusContentApiClient<C: hyper::client::Connect> {
    configuration: Rc<configuration::Configuration<C>>,
}

impl<C: hyper::client::Connect> AplusContentApiClient<C> {
    pub fn new(configuration: Rc<configuration::Configuration<C>>) -> AplusContentApiClient<C> {
        AplusContentApiClient {
            configuration: configuration,
        }
    }
}

pub trait AplusContentApi {
    fn create_content_document(&self, marketplace_id: &str, post_content_document_request: ::models::PostContentDocumentRequest) -> Box<Future<Item = ::models::PostContentDocumentResponse, Error = Error<serde_json::Value>>>;
    fn get_content_document(&self, content_reference_key: &str, marketplace_id: &str, included_data_set: Vec<String>) -> Box<Future<Item = ::models::GetContentDocumentResponse, Error = Error<serde_json::Value>>>;
    fn list_content_document_asin_relations(&self, content_reference_key: &str, marketplace_id: &str, included_data_set: Vec<String>, asin_set: Vec<String>, page_token: &str) -> Box<Future<Item = ::models::ListContentDocumentAsinRelationsResponse, Error = Error<serde_json::Value>>>;
    fn post_content_document_approval_submission(&self, content_reference_key: &str, marketplace_id: &str) -> Box<Future<Item = ::models::PostContentDocumentApprovalSubmissionResponse, Error = Error<serde_json::Value>>>;
    fn post_content_document_asin_relations(&self, content_reference_key: &str, marketplace_id: &str, post_content_document_asin_relations_request: ::models::PostContentDocumentAsinRelationsRequest) -> Box<Future<Item = ::models::PostContentDocumentAsinRelationsResponse, Error = Error<serde_json::Value>>>;
    fn post_content_document_suspend_submission(&self, content_reference_key: &str, marketplace_id: &str) -> Box<Future<Item = ::models::PostContentDocumentSuspendSubmissionResponse, Error = Error<serde_json::Value>>>;
    fn search_content_documents(&self, marketplace_id: &str, page_token: &str) -> Box<Future<Item = ::models::SearchContentDocumentsResponse, Error = Error<serde_json::Value>>>;
    fn search_content_publish_records(&self, marketplace_id: &str, asin: &str, page_token: &str) -> Box<Future<Item = ::models::SearchContentPublishRecordsResponse, Error = Error<serde_json::Value>>>;
    fn update_content_document(&self, content_reference_key: &str, marketplace_id: &str, post_content_document_request: ::models::PostContentDocumentRequest) -> Box<Future<Item = ::models::PostContentDocumentResponse, Error = Error<serde_json::Value>>>;
    fn validate_content_document_asin_relations(&self, marketplace_id: &str, post_content_document_request: ::models::PostContentDocumentRequest, asin_set: Vec<String>) -> Box<Future<Item = ::models::ValidateContentDocumentAsinRelationsResponse, Error = Error<serde_json::Value>>>;
}


impl<C: hyper::client::Connect>AplusContentApi for AplusContentApiClient<C> {
    fn create_content_document(&self, marketplace_id: &str, post_content_document_request: ::models::PostContentDocumentRequest) -> Box<Future<Item = ::models::PostContentDocumentResponse, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Post;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("marketplaceId", &marketplace_id.to_string());
            query.finish()
        };
        let uri_str = format!("{}/aplus/2020-11-01/contentDocuments?{}", configuration.base_path, query_string);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }



        let serialized = serde_json::to_string(&post_content_document_request).unwrap();
        req.headers_mut().set(hyper::header::ContentType::json());
        req.headers_mut().set(hyper::header::ContentLength(serialized.len() as u64));
        req.set_body(serialized);

        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::PostContentDocumentResponse, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn get_content_document(&self, content_reference_key: &str, marketplace_id: &str, included_data_set: Vec<String>) -> Box<Future<Item = ::models::GetContentDocumentResponse, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("marketplaceId", &marketplace_id.to_string());
            query.append_pair("includedDataSet", &included_data_set.join(",").to_string());
            query.finish()
        };
        let uri_str = format!("{}/aplus/2020-11-01/contentDocuments/{contentReferenceKey}?{}", configuration.base_path, query_string, contentReferenceKey=content_reference_key);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }




        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::GetContentDocumentResponse, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn list_content_document_asin_relations(&self, content_reference_key: &str, marketplace_id: &str, included_data_set: Vec<String>, asin_set: Vec<String>, page_token: &str) -> Box<Future<Item = ::models::ListContentDocumentAsinRelationsResponse, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("marketplaceId", &marketplace_id.to_string());
            query.append_pair("includedDataSet", &included_data_set.join(",").to_string());
            query.append_pair("asinSet", &asin_set.join(",").to_string());
            query.append_pair("pageToken", &page_token.to_string());
            query.finish()
        };
        let uri_str = format!("{}/aplus/2020-11-01/contentDocuments/{contentReferenceKey}/asins?{}", configuration.base_path, query_string, contentReferenceKey=content_reference_key);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }




        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::ListContentDocumentAsinRelationsResponse, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn post_content_document_approval_submission(&self, content_reference_key: &str, marketplace_id: &str) -> Box<Future<Item = ::models::PostContentDocumentApprovalSubmissionResponse, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Post;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("marketplaceId", &marketplace_id.to_string());
            query.finish()
        };
        let uri_str = format!("{}/aplus/2020-11-01/contentDocuments/{contentReferenceKey}/approvalSubmissions?{}", configuration.base_path, query_string, contentReferenceKey=content_reference_key);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }




        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::PostContentDocumentApprovalSubmissionResponse, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn post_content_document_asin_relations(&self, content_reference_key: &str, marketplace_id: &str, post_content_document_asin_relations_request: ::models::PostContentDocumentAsinRelationsRequest) -> Box<Future<Item = ::models::PostContentDocumentAsinRelationsResponse, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Post;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("marketplaceId", &marketplace_id.to_string());
            query.finish()
        };
        let uri_str = format!("{}/aplus/2020-11-01/contentDocuments/{contentReferenceKey}/asins?{}", configuration.base_path, query_string, contentReferenceKey=content_reference_key);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }



        let serialized = serde_json::to_string(&post_content_document_asin_relations_request).unwrap();
        req.headers_mut().set(hyper::header::ContentType::json());
        req.headers_mut().set(hyper::header::ContentLength(serialized.len() as u64));
        req.set_body(serialized);

        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::PostContentDocumentAsinRelationsResponse, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn post_content_document_suspend_submission(&self, content_reference_key: &str, marketplace_id: &str) -> Box<Future<Item = ::models::PostContentDocumentSuspendSubmissionResponse, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Post;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("marketplaceId", &marketplace_id.to_string());
            query.finish()
        };
        let uri_str = format!("{}/aplus/2020-11-01/contentDocuments/{contentReferenceKey}/suspendSubmissions?{}", configuration.base_path, query_string, contentReferenceKey=content_reference_key);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }




        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::PostContentDocumentSuspendSubmissionResponse, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn search_content_documents(&self, marketplace_id: &str, page_token: &str) -> Box<Future<Item = ::models::SearchContentDocumentsResponse, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("marketplaceId", &marketplace_id.to_string());
            query.append_pair("pageToken", &page_token.to_string());
            query.finish()
        };
        let uri_str = format!("{}/aplus/2020-11-01/contentDocuments?{}", configuration.base_path, query_string);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }




        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::SearchContentDocumentsResponse, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn search_content_publish_records(&self, marketplace_id: &str, asin: &str, page_token: &str) -> Box<Future<Item = ::models::SearchContentPublishRecordsResponse, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("marketplaceId", &marketplace_id.to_string());
            query.append_pair("asin", &asin.to_string());
            query.append_pair("pageToken", &page_token.to_string());
            query.finish()
        };
        let uri_str = format!("{}/aplus/2020-11-01/contentPublishRecords?{}", configuration.base_path, query_string);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }




        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::SearchContentPublishRecordsResponse, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn update_content_document(&self, content_reference_key: &str, marketplace_id: &str, post_content_document_request: ::models::PostContentDocumentRequest) -> Box<Future<Item = ::models::PostContentDocumentResponse, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Post;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("marketplaceId", &marketplace_id.to_string());
            query.finish()
        };
        let uri_str = format!("{}/aplus/2020-11-01/contentDocuments/{contentReferenceKey}?{}", configuration.base_path, query_string, contentReferenceKey=content_reference_key);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }



        let serialized = serde_json::to_string(&post_content_document_request).unwrap();
        req.headers_mut().set(hyper::header::ContentType::json());
        req.headers_mut().set(hyper::header::ContentLength(serialized.len() as u64));
        req.set_body(serialized);

        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::PostContentDocumentResponse, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn validate_content_document_asin_relations(&self, marketplace_id: &str, post_content_document_request: ::models::PostContentDocumentRequest, asin_set: Vec<String>) -> Box<Future<Item = ::models::ValidateContentDocumentAsinRelationsResponse, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Post;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("marketplaceId", &marketplace_id.to_string());
            query.append_pair("asinSet", &asin_set.join(",").to_string());
            query.finish()
        };
        let uri_str = format!("{}/aplus/2020-11-01/contentAsinValidations?{}", configuration.base_path, query_string);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }



        let serialized = serde_json::to_string(&post_content_document_request).unwrap();
        req.headers_mut().set(hyper::header::ContentType::json());
        req.headers_mut().set(hyper::header::ContentLength(serialized.len() as u64));
        req.set_body(serialized);

        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::ValidateContentDocumentAsinRelationsResponse, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

}
