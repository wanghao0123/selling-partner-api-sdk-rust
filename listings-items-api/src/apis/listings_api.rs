/* 
 * Selling Partner API for Listings Items
 *
 * The Selling Partner API for Listings Items (Listings Items API) provides programmatic access to selling partner listings on Amazon. Use this API in collaboration with the Selling Partner API for Product Type Definitions, which you use to retrieve the information about Amazon product types needed to use the Listings Items API.
 *
 * OpenAPI spec version: 2020-09-01
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */

use std::rc::Rc;
use std::borrow::Borrow;
use std::borrow::Cow;
use std::collections::HashMap;

use hyper;
use serde_json;
use futures;
use futures::{Future, Stream};

use hyper::header::UserAgent;

use super::{Error, configuration};

pub struct ListingsApiClient<C: hyper::client::Connect> {
    configuration: Rc<configuration::Configuration<C>>,
}

impl<C: hyper::client::Connect> ListingsApiClient<C> {
    pub fn new(configuration: Rc<configuration::Configuration<C>>) -> ListingsApiClient<C> {
        ListingsApiClient {
            configuration: configuration,
        }
    }
}

pub trait ListingsApi {
    fn delete_listings_item(&self, seller_id: &str, sku: &str, marketplace_ids: Vec<String>, issue_locale: &str) -> Box<Future<Item = ::models::ListingsItemSubmissionResponse, Error = Error<serde_json::Value>>>;
    fn patch_listings_item(&self, seller_id: &str, sku: &str, marketplace_ids: Vec<String>, body: ::models::ListingsItemPatchRequest, issue_locale: &str) -> Box<Future<Item = ::models::ListingsItemSubmissionResponse, Error = Error<serde_json::Value>>>;
    fn put_listings_item(&self, seller_id: &str, sku: &str, marketplace_ids: Vec<String>, body: ::models::ListingsItemPutRequest, issue_locale: &str) -> Box<Future<Item = ::models::ListingsItemSubmissionResponse, Error = Error<serde_json::Value>>>;
}


impl<C: hyper::client::Connect>ListingsApi for ListingsApiClient<C> {
    fn delete_listings_item(&self, seller_id: &str, sku: &str, marketplace_ids: Vec<String>, issue_locale: &str) -> Box<Future<Item = ::models::ListingsItemSubmissionResponse, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Delete;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("marketplaceIds", &marketplace_ids.join(",").to_string());
            query.append_pair("issueLocale", &issue_locale.to_string());
            query.finish()
        };
        let uri_str = format!("{}/listings/2020-09-01/items/{sellerId}/{sku}?{}", configuration.base_path, query_string, sellerId=seller_id, sku=sku);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }




        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::ListingsItemSubmissionResponse, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn patch_listings_item(&self, seller_id: &str, sku: &str, marketplace_ids: Vec<String>, body: ::models::ListingsItemPatchRequest, issue_locale: &str) -> Box<Future<Item = ::models::ListingsItemSubmissionResponse, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Patch;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("marketplaceIds", &marketplace_ids.join(",").to_string());
            query.append_pair("issueLocale", &issue_locale.to_string());
            query.finish()
        };
        let uri_str = format!("{}/listings/2020-09-01/items/{sellerId}/{sku}?{}", configuration.base_path, query_string, sellerId=seller_id, sku=sku);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }



        let serialized = serde_json::to_string(&body).unwrap();
        req.headers_mut().set(hyper::header::ContentType::json());
        req.headers_mut().set(hyper::header::ContentLength(serialized.len() as u64));
        req.set_body(serialized);

        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::ListingsItemSubmissionResponse, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

    fn put_listings_item(&self, seller_id: &str, sku: &str, marketplace_ids: Vec<String>, body: ::models::ListingsItemPutRequest, issue_locale: &str) -> Box<Future<Item = ::models::ListingsItemSubmissionResponse, Error = Error<serde_json::Value>>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Put;

        let query_string = {
            let mut query = ::url::form_urlencoded::Serializer::new(String::new());
            query.append_pair("marketplaceIds", &marketplace_ids.join(",").to_string());
            query.append_pair("issueLocale", &issue_locale.to_string());
            query.finish()
        };
        let uri_str = format!("{}/listings/2020-09-01/items/{sellerId}/{sku}?{}", configuration.base_path, query_string, sellerId=seller_id, sku=sku);

        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut uri: hyper::Uri = uri_str.parse().unwrap();

        let mut req = hyper::Request::new(method, uri);

        if let Some(ref user_agent) = configuration.user_agent {
            req.headers_mut().set(UserAgent::new(Cow::Owned(user_agent.clone())));
        }



        let serialized = serde_json::to_string(&body).unwrap();
        req.headers_mut().set(hyper::header::ContentType::json());
        req.headers_mut().set(hyper::header::ContentLength(serialized.len() as u64));
        req.set_body(serialized);

        // send request
        Box::new(
        configuration.client.request(req)
            .map_err(|e| Error::from(e))
            .and_then(|resp| {
                let status = resp.status();
                resp.body().concat2()
                    .and_then(move |body| Ok((status, body)))
                    .map_err(|e| Error::from(e))
            })
            .and_then(|(status, body)| {
                if status.is_success() {
                    Ok(body)
                } else {
                    Err(Error::from((status, &*body)))
                }
            })
            .and_then(|body| {
                let parsed: Result<::models::ListingsItemSubmissionResponse, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            })
        )
    }

}
